# ü§ü Hello Dev. MerrisonFord here.

Most data science projects die in a notebook with some promising plots and a vague sense of hope.  
That's where I usually start.

I'm not interested in ‚Äúit kinda works.‚Äù I care about what happens *after*:  
- What does it take to make this thing reliable?  
- How do you stop it from silently crashing at 3 AM?  
- How do you deploy something without making your infra team hate you?

This is where engineering begins. I build ML systems like software: with versioning, tests, monitoring, and docs written clearly enough that future-me won‚Äôt quit on the spot. Not because it‚Äôs trendy. Because it‚Äôs the difference between a cool demo and something that survives in production.

I don‚Äôt collect technologies like Pok√©mon. I figure out how they fit together so I can sleep at night.

---

##  What I‚Äôm building

**Production-grade anomaly detection**  
Taking a computer vision model from "lab toy" to "you can deploy this without summoning SREs through a ritual circle". Monitoring, health checks, logging, the works.

**End-to-end ML pipelines**  
Manually rerunning scripts is for masochists. I use Airflow to automate everything: ingestion, training, deployment. I like to sleep. Pipelines help.

**WOLLI**  
A personal AI system that refuses to stay simple. Modular, evolving, occasionally unhinged. It reviews its own code (mostly). It reflects my need to build AI tools that don‚Äôt suck‚Äîand that challenge me in return.

**Real MLOps**  
Versioning models. Testing them like software. Knowing when something‚Äôs degrading *before* a user finds out. You know‚Äîreal stuff.

---

## ÔøΩ What I actually use

**Languages**: Python (daily driver), Java (when forced), Bash (because it's sorcery)  
**Infra & workflow**: Docker, GitHub Actions, Airflow, MLflow  
**ML & data**: pandas, NumPy, scikit-learn, PyTorch, OpenCV  
**Cloud**: AWS, Azure, GCP (they all do the same thing badly in different ways)  
**Databases**: PostgreSQL, MySQL, Redis (fast and angry)  
**Environment**: Linux, macOS, terminal-heavy (if it has a GUI, I don‚Äôt trust it)

---

##  How I learn

I don‚Äôt just learn tools. I learn **why they were built**, and **what pain they were trying to solve**.  
I want to understand:
- Why Docker became mandatory (beyond ‚Äúit works on my machine‚Äù)  
- When Airflow makes sense and when a cron job is just fine  
- How to tell if a model is actually doing its job‚Äîor just failing creatively in silence

If I break something, I break it hard.  
Then I fix it properly.

---

## TL;DR

- Build ML systems that *actually* work in production  
- Automate pipelines so I don‚Äôt lose sleep  
- Architect code like someone will have to maintain it (because they will‚Äîit‚Äôs me)  
- Design WOLLI, my AI sidekick with commitment issues and strong opinions

---

*Open to opportunities where breaking things is part of the job.*  
